# Database Design & Setup: Explained

This document breaks down the database structure for the Money Tracking application. Understanding this is key to grasping how the application stores and manages financial data.

## 1. Why a Relational Database (PostgreSQL)?

The project uses PostgreSQL, a powerful open-source relational database. Here’s why it’s a good choice:

*   **Structured Data**: Financial data is naturally structured. Transactions, categories, and users have clear attributes (like date, amount, name) and relationships (a transaction belongs to a category, a transaction belongs to a user). Relational databases excel at managing this kind of structured data.
*   **Data Integrity**: PostgreSQL enforces rules to ensure data is consistent and reliable. For example, you can't add a transaction for a category that doesn’t exist. This is crucial for a financial application where accuracy is paramount.
*   **Powerful Queries**: With SQL (Structured Query Language), you can perform complex queries to analyze your financial data. For example, you can easily calculate total spending per category for a specific month or find your average income over the last year.
*   **Scalability & Reliability**: PostgreSQL is known for its robustness and ability to handle large amounts of data, making it suitable for applications that may grow over time.

The use of PostgreSQL is confirmed in the `docker-compose.yaml` file, where the `warehouse` service is defined using the `postgres:13` image.

## 2. The Data Model: Tables and Relationships

The database schema is defined through a series of "migration" files. These are SQL scripts that build the database structure step-by-step. Let's look at the tables they create:

### `expense_categories`

*   **Purpose**: Stores broad categories for your transactions (e.g., "Income", "Housing Fixed Costs", "Personal Running Costs").
*   **Columns**:
    *   `id`: A unique identifier for each category (Primary Key).
    *   `category_name`: The name of the category (e.g., "Travel Costs").

### `expense_types`

*   **Purpose**: Stores specific types of transactions within a category. This provides a more granular classification. For example, within the "Personal Running Costs" category, you might have types like "Groceries", "Gym", or "Mobile Phone".
*   **Columns**:
    *   `id`: A unique identifier for each type (Primary Key).
    *   `type_name`: The name of the type (e.g., "Salary", "Rent").
    *   `category_id`: A reference to the `id` in the `expense_categories` table. This creates a **one-to-many relationship**: one category can have many types, but each type belongs to only one category.

### `users`

*   **Purpose**: Stores user account information.
*   **Columns**:
    *   `id`: A unique identifier for each user (Primary Key).
    *   `email`: The user's email address, used for login. It's marked as `UNIQUE` to prevent duplicate accounts.
    *   `password_hash`: Stores the user's password in a securely hashed format.
    *   `created_at`: The date and time the user account was created.

### `transactions`

*   **Purpose**: This is the central table, storing every financial transaction.
*   **Columns**:
    *   `id`: A unique identifier for each transaction (Primary Key).
    *   `date`: The date the transaction occurred.
    *   `amount`: The monetary value of the transaction.
    *   `type_id`: A reference to the `id` in the `expense_types` table.
    *   `category_id`: A reference to the `id` in the `expense_categories` table.
    *   `user_id`: A reference to the `id` in the `users` table. This links each transaction to a specific user.

### Relationships Summary:

*   A `user` can have many `transactions`.
*   A `transaction` belongs to one `user`.
*   A `transaction` has one `expense_type` and one `expense_category`.
*   An `expense_type` belongs to one `expense_category`.
*   An `expense_category` can have many `expense_types`.

This structure allows for efficient querying and ensures that the data remains organized and consistent.

## 3. Understanding Database Migrations

The files in the `database/migrations/` directory are crucial for managing the database schema over time. Here’s how they work:

*   **What are they?**: Each file is a script that applies a change to the database, like creating a table, adding a column, or inserting initial data. They are timestamped to ensure they run in the correct order.
*   **Why use them?**:
    *   **Version Control for Your Database**: Just like Git for your code, migrations allow you to track changes to your database schema.
    *   **Collaboration**: When working in a team, migrations ensure that everyone has the same database structure.
    *   **Reproducibility**: You can easily set up a new database for development or testing by running all the migrations in order.

### The Migration Files in This Project:

1.  `20240305063418723_create-main-tables.sql`: This is the first migration. It creates the initial tables: `expense_categories`, `expense_types`, and `transactions`.
2.  `20240305063429859_create-data-model.sql`: This migration populates the `expense_categories` and `expense_types` tables with initial data (like "Income", "Groceries", etc.) and inserts some test transactions. This is often called "seeding" the database.
3.  `20240717120000_add-users-table.sql`: This migration introduces user functionality. It creates the `users` table and adds the `user_id` column to the `transactions` table to link transactions to users.

By examining these files in order, you can see the evolution of the database schema from a simple expense tracker to a multi-user application.
