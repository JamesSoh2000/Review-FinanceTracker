JamesSoh2000: You are an expert on interview in software engineering industry. Walk me through the architecture of the Personal Finance Tracker project in "/home/james/Personal/Money Tracking/Original Project". How do the frontend, backend, and database interact? Give me detailed explanation as best as possible.

Workspace: Collecting workspace information# Architecture Overview of the Personal Finance Tracker

Let me walk you through the complete architecture of this containerized full-stack application, explaining how each layer interacts.

## High-Level Architecture

This is a **three-tier architecture** with clear separation of concerns:

```
User Browser → Frontend (React) → Backend (Node.js/Express) → Database (PostgreSQL)
```

All components are containerized using Docker, orchestrated by [docker-compose.yaml](Money Tracking/Original Project/docker-compose.yaml).

---

## 1. Frontend Layer (React + TypeScript)

### Entry Point & Structure
The application starts at [src/index.tsx](Money Tracking/Original Project/frontend/src/index.tsx), which renders the main [App.tsx](Money Tracking/Original Project/frontend/src/App.tsx) component wrapped in an [`AuthProvider`](Money Tracking/Original Project/frontend/src/context/AuthContext.tsx).

### Key Architecture Patterns

#### **Authentication Context Pattern**
The [`AuthContext`](Money Tracking/Original Project/frontend/src/context/AuthContext.tsx) provides global authentication state:
- Stores JWT token and userId in both React state and localStorage
- Provides `login()` and `logout()` methods to all child components
- Automatically redirects users based on authentication status

#### **Protected Routing**
[App.tsx](Money Tracking/Original Project/frontend/src/App.tsx) implements conditional routing:
````typescript
{!authContext?.isLoggedIn ? (
    <Route path="/login" element={<LoginPage />} />
    <Route path="*" element={<Navigate to="/login" />} />
) : (
    <Route path="/cashflow" element={<CashFlow />} />
    <Route path="*" element={<Navigate to="/" />} />
)}
````

#### **Centralized API Communication**
The [`apiFetch`](Money Tracking/Original Project/frontend/src/utils/apiFetch.ts) utility wraps all API calls:
- Automatically handles authentication (adds JWT to headers)
- Catches 401/403/500 errors and triggers logout
- Provides consistent error handling across the app

### Component Architecture

The main dashboard ([cashflow/index.tsx](Money Tracking/Original Project/frontend/src/pages/cashflow/index.tsx)) uses a **grid-based layout**:
- **Row1.tsx**: Financial overview metrics, income/expense charts
- **Row2.tsx**: Time series data, expense categories, transaction list
- **ExpenseFormModal.tsx**: Floating action button for adding transactions

Components use **reusable styled components**:
- [`DashboardBox`](Money Tracking/Original Project/frontend/src/components/DashboardBox.tsx): Consistent card styling
- [`BoxHeader`](Money Tracking/Original Project/frontend/src/components/BoxHeader.tsx): Standardized card headers
- [`FlexBetween`](Money Tracking/Original Project/frontend/src/components/FlexBetween.tsx): Common layout pattern

### Data Flow in Frontend

1. **User logs in** via [login/index.tsx](Money Tracking/Original Project/frontend/src/pages/login/index.tsx)
2. Frontend sends credentials to `http://localhost:8000/auth/login`
3. Receives JWT token and stores it via `AuthContext.login()`
4. Dashboard components fetch data using protected endpoints:
   - `/feed/financial-overview` → Aggregated metrics
   - `/feed/timeseries` → Chart data
   - `/feed/list-expenses` → Transaction table

Example from [Row1.tsx](Money Tracking/Original Project/frontend/src/pages/cashflow/Row1.tsx):
````typescript
const response = await apiFetch(
    `${baseUrl}/feed/financial-overview`, 
    { headers: { 'Authorization': `Bearer ${authContext.token}` } },
    authContext
);
const data: FinancialData[] = await response.json();
setFinancialData(data);
````

---

## 2. Backend Layer (Node.js + Express + TypeScript)

### Entry Point
The backend starts at [src/tracker.ts](Money Tracking/Original Project/backend/src/tracker.ts), which:
- Configures CORS to allow frontend requests
- Registers two main route groups: `/auth` and `/feed`
- Implements global error handling (including Zod validation errors)

### Layered Architecture

The backend follows a **Controller → Service → Database** pattern:

#### **Routes Layer** ([routes/](Money Tracking/Original Project/backend/src/routes/))
Defines endpoints and applies middleware:
````typescript
// auth.ts
router.post('/signup', authController.signup);
router.post('/login', authController.login);

// feed.ts
router.post('/transaction', isAuth, feedController.createTransaction);
router.get('/financial-overview', isAuth, feedController.getFinancialOverview);
````

The [`isAuth`](Money Tracking/Original Project/backend/src/middleware/is-auth.ts) middleware protects routes by:
1. Extracting JWT from `Authorization` header
2. Verifying the token using `JWT_SECRET`
3. Attaching `userId` to the request object
4. Rejecting invalid/expired tokens with 401

#### **Controllers Layer** ([controllers/](Money Tracking/Original Project/backend/src/controllers/))
Handle HTTP request/response logic:
- Validate input using Zod schemas
- Call service functions
- Return appropriate HTTP status codes

Example from [auth.controller.ts](Money Tracking/Original Project/backend/src/controllers/auth.controller.ts):
````typescript
export const login = async (req: Request, res: Response, next: NextFunction) => {
    const { email, password } = userSchema.parse(req.body);
    const user = await authService.findUserByEmail(email);
    
    if (!user || !await bcrypt.compare(password, user.password_hash)) {
        return res.status(401).json({ message: 'Invalid credentials.' });
    }
    
    const token = jwt.sign({ userId: user.id, email }, secret, { expiresIn: '1h' });
    return res.status(200).json({ token, userId: user.id });
};
````

#### **Services Layer** ([services/](Money Tracking/Original Project/backend/src/services/))
Contain business logic and database queries:
- Pure functions that interact with the database
- User-scoped queries (always filter by `user_id`)
- Complex SQL queries with joins and aggregations

Example from [feed.service.ts](Money Tracking/Original Project/backend/src/services/feed.service.ts):
````typescript
export const getTimeSeries = (userId: string) => {
    return query(`
        SELECT SUM(t.amount) AS total, 
               TO_CHAR(t.date, 'YYYY-MM') AS time,
               et.type_name
        FROM transactions t
        JOIN expense_types et ON et.id = t.type_id 
        WHERE t.user_id = $1 AND TO_CHAR(t.date, 'YYYY') > '2024'
        GROUP BY 2, 3
    `, [userId]);
};
````

### Authentication Flow

1. **Signup** ([auth.controller.ts](Money Tracking/Original Project/backend/src/controllers/auth.controller.ts)):
   - Hash password with bcrypt (12 rounds)
   - Store user in database via [`authService.createUser`](Money Tracking/Original Project/backend/src/services/auth.service.ts)

2. **Login**:
   - Verify credentials
   - Generate JWT containing `userId` and `email`
   - Return token with 1-hour expiration

3. **Protected Requests**:
   - Frontend includes `Authorization: Bearer <token>` header
   - [`isAuth`](Money Tracking/Original Project/backend/src/middleware/is-auth.ts) middleware verifies token
   - Extracts `userId` and attaches to request
   - Controllers use `req.userId` to scope queries

---

## 3. Database Layer (PostgreSQL)

### Schema Management

The database uses a **migration system** managed by [node-pg-migrate](Money Tracking/Original Project/database/src/runner.ts):

#### **Migration Files** ([migrations/](Money Tracking/Original Project/database/migrations/))
1. **[20240305063418723_create-main-tables.sql](Money Tracking/Original Project/database/migrations/20240305063418723_create-main-tables.sql)**
   - Creates core tables: `expense_categories`, `expense_types`, `transactions`

2. **[20240305063429859_create-data-model.sql](Money Tracking/Original Project/database/migrations/20240305063429859_create-data-model.sql)**
   - Seeds initial data (categories, types, sample transactions)

3. **[20240717120000_add-users-table.sql](Money Tracking/Original Project/database/migrations/20240717120000_add-users-table.sql)**
   - Adds `users` table
   - Adds `user_id` foreign key to `transactions`

### Data Model

The schema has **4 main tables** with relationships:

```
users (1) ──< (many) transactions (many) >── (1) expense_types (many) >── (1) expense_categories
```

#### **Key Tables:**
- **users**: Authentication data (email, password_hash)
- **transactions**: Individual income/expense records with `user_id`, `date`, `amount`
- **expense_types**: Specific types (e.g., "Groceries", "Rent") → belongs to category
- **expense_categories**: High-level groups (e.g., "Personal Fixed Costs", "Housing")

### Complex Queries & SQL Functions

The database includes **stored procedures** in [seeds/](Money Tracking/Original Project/database/seeds/):

#### **[get_financial_overview.sql](Money Tracking/Original Project/database/seeds/cashflow/get_financial_overview.sql)**
A complex SQL function that:
1. Aggregates transactions by year and category
2. Calculates total income vs expenses
3. Computes savings rate: `(net_income / total_income) * 100`
4. Returns cumulative net income over time

Called from backend as:
````typescript
export const getFinancialOverview = (userId: string) => {
    return query('SELECT * from get_financial_metrics($1)', [userId]);
};
````

#### **[get_income_expense.sql](Money Tracking/Original Project/database/seeds/cashflow/get_income_expense.sql)**
Returns monthly income, expenses, and savings rate in a format optimized for charting.

---

## 4. Complete Request Flow Example

Let's trace a complete request: **"User adds a new expense"**

### Step 1: User Interaction (Frontend)
1. User clicks FAB in [ExpenseFormModal.tsx](Money Tracking/Original Project/frontend/src/components/ExpenseFormModal.tsx)
2. Fills form: amount, type, category
3. Clicks "Add Expense"

### Step 2: API Call
````typescript
const response = await apiFetch('http://localhost:8000/feed/transaction', {
    method: 'POST',
    headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${authContext?.token}`
    },
    body: JSON.stringify({ date, amount, typeId, categoryId })
}, authContext);
````

### Step 3: Backend Routing
Request hits [routes/feed.ts](Money Tracking/Original Project/backend/src/routes/feed.ts):
````typescript
router.post('/transaction', isAuth, feedController.createTransaction);
````

### Step 4: Authentication Middleware
[`isAuth`](Money Tracking/Original Project/backend/src/middleware/is-auth.ts) middleware:
- Extracts token from header
- Verifies JWT signature
- Attaches `userId` to request
- If invalid → 401 response

### Step 5: Controller Processing
[feed.ts controller](Money Tracking/Original Project/backend/src/controllers/feed.ts):
````typescript
export const createTransaction = async (req: AuthenticatedRequest, res: Response) => {
    const { date, amount, typeId, categoryId } = transactionSchema.parse(req.body);
    const userId = req.userId; // From middleware
    
    const result = await feedService.createTransaction(date, amount, typeId, categoryId, userId);
    return res.status(201).json({ transaction: result.rows[0] });
};
````

### Step 6: Service Layer
[feed.service.ts](Money Tracking/Original Project/backend/src/services/feed.service.ts):
````typescript
export const createTransaction = (date, amount, typeId, categoryId, userId) => {
    return query(
        'INSERT INTO transactions (date, amount, type_id, category_id, user_id) VALUES ($1, $2, $3, $4, $5) RETURNING *',
        [date, amount, typeId, categoryId, userId]
    );
};
````

### Step 7: Database Insertion
PostgreSQL:
1. Validates foreign keys (type_id, category_id exist)
2. Inserts row with `user_id` for data isolation
3. Returns inserted row

### Step 8: Response Flow
````
Database → Service → Controller → Route → Express → Frontend
````

### Step 9: UI Update
Frontend:
1. Receives 201 response
2. Calls `onExpenseAdded()` callback
3. Dashboard refreshes data via `setRefreshKey(prev => prev + 1)`
4. Charts re-fetch and update

---

## 5. Containerization & Communication

### Docker Architecture

The [docker-compose.yaml](Money Tracking/Original Project/docker-compose.yaml) defines **4 services**:

1. **database**: PostgreSQL container
   - Exposes port 5432
   - Stores data in named volume

2. **database-migrations**: Runs once to set up schema
   - Executes [src/runMigrations.ts](Money Tracking/Original Project/database/src/runMigrations.ts)
   - Applies SQL migrations and seeds

3. **backend**: Node.js/Express API
   - Exposes port 8000
   - Depends on `database` service
   - Environment variables: `POSTGRES_HOST=database` (Docker internal networking)

4. **frontend**: React app served by Nginx
   - Exposes port 3001
   - Proxies API calls to `backend:8000`

### Inter-Container Communication

Containers communicate via **Docker's internal network**:
- Frontend → Backend: `http://backend:8000` (internal DNS)
- Backend → Database: `postgres://database:5432` (connection string)
- User → Frontend: `http://localhost:3001` (host machine)

---

## 6. Security Considerations

### Authentication Security
- **Password Hashing**: bcrypt with salt rounds (12)
- **JWT Tokens**: Signed with `JWT_SECRET`, 1-hour expiration
- **Token Storage**: localStorage (trade-off: XSS vulnerability, but simpler than httpOnly cookies)

### Authorization
- **User Isolation**: All queries filter by `user_id` from verified JWT
- **Middleware Protection**: All sensitive routes use [`isAuth`](Money Tracking/Original Project/backend/src/middleware/is-auth.ts)

### Input Validation
- **Zod Schemas**: Validate all incoming data before processing
- **SQL Injection Protection**: Parameterized queries via `pg` library

### CORS Configuration
- Backend allows all origins (`origin: "*"`) for development
- Production would restrict to specific frontend domain

---

## 7. Data Flow Summary

### User Login Flow
```
LoginPage → POST /auth/login → Verify credentials → Generate JWT → Store in localStorage + Context
```

### Dashboard Load Flow
```
CashFlow component mounts
    ↓
Row1 & Row2 fetch data in parallel
    ↓
apiFetch adds JWT to headers
    ↓
Backend validates token → Queries DB with user_id filter
    ↓
Returns JSON data → Frontend updates state → Charts render
```

### Add Transaction Flow
```
ExpenseFormModal submit
    ↓
POST /feed/transaction (with JWT)
    ↓
isAuth middleware validates
    ↓
Controller validates + calls service
    ↓
Service inserts into transactions table
    ↓
Response returns → Frontend refreshes dashboard
```

---

## Key Architectural Strengths

1. **Clear Separation of Concerns**: Frontend/Backend/Database are independently deployable
2. **Type Safety**: TypeScript across entire stack prevents runtime errors
3. **Security-First**: JWT authentication, bcrypt hashing, user data isolation
4. **Scalability**: Stateless backend allows horizontal scaling
5. **Developer Experience**: Docker Compose enables one-command setup
6. **Maintainability**: Layered architecture (Controller/Service/Route) makes code easy to modify

This architecture demonstrates production-ready patterns suitable for modern web applications, with proper authentication, authorization, and data isolation.