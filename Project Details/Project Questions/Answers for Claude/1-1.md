JamesSoh2000: You are an expert on interview in software engineering industry. Walk me through the architecture of the Personal Finance Tracker project in "/home/james/Personal/Money Tracking/Original Project". How do the frontend, backend, and database interact? Give me detailed explanation as best as possible.

Workspace: Collecting workspace information# Personal Finance Tracker - Architecture Deep Dive

Let me walk you through the complete architecture of this full-stack application, from the user interface down to the database layer.

---

## **High-Level Architecture Overview**

This is a **3-tier containerized application** with clear separation of concerns:

```
┌─────────────────┐
│  React Frontend │ (Port 3001)
│   (TypeScript)  │
└────────┬────────┘
         │ HTTP/REST
         ▼
┌─────────────────┐
│ Node.js Backend │ (Port 8000)
│ Express + JWT   │
└────────┬────────┘
         │ SQL Queries
         ▼
┌─────────────────┐
│   PostgreSQL    │ (Port 5432)
│    Database     │
└─────────────────┘
```

All three components run in **Docker containers** orchestrated by [`docker-compose.yaml`](Money Tracking/Original Project/docker-compose.yaml).

---

## **1. Frontend Layer (React/TypeScript)**

### **Core Responsibilities**
- User authentication UI
- Financial dashboard with charts
- Transaction management
- Protected routing based on authentication state

### **Key Components**

#### **Authentication Flow**
[`src/context/AuthContext.tsx`](Money Tracking/Original Project/frontend/src/context/AuthContext.tsx) manages the entire auth state:

```typescript
interface AuthContextType {
    token: string | null;        // JWT token
    userId: string | null;       // User identifier
    isLoggedIn: boolean;         // Auth status
    login: (token, userId) => void;
    logout: () => void;
}
```

**Login Process** ([`src/pages/login/index.tsx`](Money Tracking/Original Project/frontend/src/pages/login/index.tsx)):
1. User enters credentials
2. Frontend sends POST to `http://localhost:8000/auth/login`
3. Receives JWT token + userId
4. Stores in `localStorage` and `AuthContext`
5. Redirects to `/cashflow`

```typescript
const response = await fetch('http://localhost:8000/auth/login', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ email, password })
});
const data = await response.json();
login(data.token, data.userId); // Updates context
```

#### **Protected API Calls**
[`src/utils/apiFetch.ts`](Money Tracking/Original Project/frontend/src/utils/apiFetch.ts) wraps `fetch()` to:
- Automatically logout on 401/403/500 errors
- Handle expired sessions gracefully

```typescript
export async function apiFetch(url, options, authContext) {
  const response = await fetch(url, options);
  if (response.status === 401 || response.status === 403) {
    authContext.logout(); // Clear auth state
    throw new Error('Session expired');
  }
  return response;
}
```

#### **Dashboard Components**
The main dashboard ([`src/pages/cashflow/index.tsx`](Money Tracking/Original Project/frontend/src/pages/cashflow/index.tsx)) contains:

1. **Row1.tsx** - Financial Overview:
   - Shows accumulated income, net income, savings rate
   - Bar charts for expense breakdown by category
   - Data fetched from `/feed/financial-overview` and `/feed/financial-details`

2. **Row2.tsx** - Time Series Analysis:
   - Stacked bar chart of expense types over time
   - Line chart for expense categories with click-to-isolate
   - Transaction list table (DataGrid)
   - Data from `/feed/timeseries`, `/feed/financial-details`, `/feed/list-expenses`

3. **ExpenseFormModal.tsx** - Transaction Entry:
   - Floating action button (FAB) for adding expenses
   - Dynamically loads categories from `/feed/expense-categories`
   - Posts new transactions to `/feed/transaction`

**Example API Call with Auth** ([`Row1.tsx`](Money Tracking/Original Project/frontend/src/pages/cashflow/Row1.tsx)):
```typescript
const headers = {
    'Content-Type': 'application/json',
    'Authorization': `Bearer ${authContext.token}` // JWT in header
};

const response = await apiFetch(
    'http://localhost:8000/feed/financial-overview', 
    { headers }, 
    authContext
);
const data = await response.json();
```

---

## **2. Backend Layer (Node.js/Express/TypeScript)**

### **Architecture Pattern: MVC-like Structure**

```
Routes → Controllers → Services → Database
  ↓         ↓           ↓           ↓
HTTP     Business    DB Logic    Postgres
Layer     Logic      Layer
```

### **Entry Point: [`src/tracker.ts`](Money Tracking/Original Project/backend/src/tracker.ts)**

```typescript
const app = express();

// Middleware
app.use(cors({ origin: "*" }));
app.use(bodyParser.json());

// Route Registration
app.use('/auth', authRoutes);  // Public auth endpoints
app.use('/feed', feedRoutes);  // Protected data endpoints

// Global Error Handler
app.use((error, req, res, next) => {
    // Handles Zod validation errors + general errors
});
```

---

### **Authentication System**

#### **Public Routes** ([`src/routes/auth.ts`](Money Tracking/Original Project/backend/src/routes/auth.ts))
```typescript
router.post('/signup', authController.signup);
router.post('/login', authController.login);
```

#### **Auth Controller** ([`src/controllers/auth.controller.ts`](Money Tracking/Original Project/backend/src/controllers/auth.controller.ts))

**Signup Flow:**
```typescript
export const signup = async (req, res, next) => {
    const { email, password } = userSchema.parse(req.body); // Zod validation
    
    // Check for existing user
    const existingUser = await authService.findUserByEmail(email);
    if (existingUser) {
        return res.status(409).json({ message: 'Email exists' });
    }
    
    // Create user (password hashed in service layer)
    const user = await authService.createUser(email, password);
    return res.status(201).json({ message: 'User created' });
};
```

**Login Flow:**
```typescript
export const login = async (req, res, next) => {
    const { email, password } = userSchema.parse(req.body);
    
    const user = await authService.findUserByEmail(email);
    if (!user) return res.status(401).json({ message: 'Invalid credentials' });
    
    // Verify password
    const isEqual = await bcrypt.compare(password, user.password_hash);
    if (!isEqual) return res.status(401).json({ message: 'Invalid credentials' });
    
    // Generate JWT
    const token = jwt.sign(
        { userId: user.id, email: user.email },
        process.env.JWT_SECRET,
        { expiresIn: '1h' }
    );
    
    return res.status(200).json({ token, userId: user.id });
};
```

#### **Auth Service** ([`src/services/auth.service.ts`](Money Tracking/Original Project/backend/src/services/auth.service.ts))
```typescript
export const createUser = async (email: string, password: string) => {
    const hashedPassword = await bcrypt.hash(password, 12); // 12 salt rounds
    const result = await query(
        'INSERT INTO users (email, password_hash) VALUES ($1, $2) RETURNING id, email',
        [email, hashedPassword]
    );
    return result.rows[0];
};
```

---

### **Protected Data Routes**

#### **JWT Middleware** ([`src/middleware/is-auth.ts`](Money Tracking/Original Project/backend/src/middleware/is-auth.ts))

**Every `/feed` route passes through this:**
```typescript
export default (req: AuthenticatedRequest, res, next) => {
    const authHeader = req.get('Authorization'); // "Bearer <token>"
    if (!authHeader) {
        return res.status(401).json({ message: 'Not authenticated' });
    }
    
    const token = authHeader.split(' ')[1];
    
    try {
        const decodedToken = jwt.verify(token, process.env.JWT_SECRET);
        req.userId = decodedToken.userId; // Attach userId to request
        next();
    } catch (err) {
        return res.status(500).json({ message: 'Token verification failed' });
    }
};
```

#### **Feed Routes** ([`src/routes/feed.ts`](Money Tracking/Original Project/backend/src/routes/feed.ts))
```typescript
// Public - no auth needed
router.get('/expense-categories', feedController.getExpenseCategories);

// All below routes use isAuth middleware
router.post('/transaction', isAuth, feedController.createTransaction);
router.get('/timeseries', isAuth, feedController.getTimeSeries);
router.get('/financial-overview', isAuth, feedController.getFinancialOverview);
router.get('/list-expenses', isAuth, feedController.getExpenseTable);
```

#### **Feed Controller** ([`src/controllers/feed.ts`](Money Tracking/Original Project/backend/src/controllers/feed.ts))

**Example: Creating a Transaction**
```typescript
export const createTransaction = async (req: AuthenticatedRequest, res, next) => {
    const { date, amount, typeId, categoryId } = transactionSchema.parse(req.body);
    const userId = req.userId; // Extracted from JWT by middleware
    
    if (!userId) {
        return res.status(401).json({ message: 'Not authenticated' });
    }
    
    const result = await feedService.createTransaction(
        date, amount, typeId, categoryId, userId
    );
    
    return res.status(201).json({
        message: 'Transaction created',
        transaction: result.rows[0]
    });
};
```

**Example: Fetching User's Time Series Data**
```typescript
export const getTimeSeries = async (req: AuthenticatedRequest, res, next) => {
    const userId = req.userId; // From JWT
    if (!userId) {
        return res.status(401).json({ message: 'Not authenticated' });
    }
    
    const result = await feedService.getTimeSeries(userId);
    return res.status(200).json(result.rows);
};
```

#### **Feed Service** ([`src/services/feed.service.ts`](Money Tracking/Original Project/backend/src/services/feed.service.ts))

**All queries filter by `user_id` to isolate data:**

```typescript
export const getTimeSeries = (userId: string) => {
    return query(
      `SELECT 
        SUM(t.amount) AS total, 
        TO_CHAR(t.date, 'YYYY-MM') AS time,
        et.type_name
      FROM transactions t
      JOIN expense_types et ON et.id = t.type_id 
      WHERE et.type_name NOT IN ('Salary', 'Bonus', 'Rent')
      AND TO_CHAR(t.date, 'YYYY') > '2024'
      AND t.user_id = $1  -- ← Critical: filters by logged-in user
      GROUP BY 2, 3`,
      [userId]
    );
};

export const getExpenseTable = (userId: string) => {
    return query(
      `SELECT  
        TO_CHAR(t.date, 'YYYY-MM-DD') as date,
        t.amount,
        et.type_name as type,
        ec.category_name as category
      FROM transactions t
      INNER JOIN expense_categories ec ON ec.id = t.category_id 
      INNER JOIN expense_types et ON et.id = t.type_id 
      WHERE ec.category_name != 'Income'
      AND TO_CHAR(t.date, 'YYYY') > '2024'
      AND t.user_id = $1  -- ← Data isolation
      ORDER BY date DESC`,
      [userId]
    );
};
```

---

## **3. Database Layer (PostgreSQL)**

### **Schema Design**

#### **Core Tables** ([`migrations/20240305063418723_create-main-tables.sql`](Money Tracking/Original Project/database/migrations/20240305063418723_create-main-tables.sql))

```sql
CREATE TABLE expense_categories (
    id SERIAL PRIMARY KEY,
    category_name VARCHAR(255) NOT NULL
    -- Examples: 'Income', 'Housing Fixed Costs', 'Personal Running Costs'
);

CREATE TABLE expense_types (
    id SERIAL PRIMARY KEY,
    type_name VARCHAR(255) NOT NULL,
    category_id INT NOT NULL,
    FOREIGN KEY (category_id) REFERENCES expense_categories(id)
    -- Examples: 'Groceries' under 'Personal Fixed Costs'
);

CREATE TABLE transactions (
    id SERIAL PRIMARY KEY,
    date DATE NOT NULL,
    amount DECIMAL(10, 2) NOT NULL,
    type_id INT NOT NULL,
    category_id INT NOT NULL,
    FOREIGN KEY (type_id) REFERENCES expense_types(id),
    FOREIGN KEY (category_id) REFERENCES expense_categories(id)
);
```

#### **User Authentication** ([`migrations/20240717120000_add-users-table.sql`](Money Tracking/Original Project/database/migrations/20240717120000_add-users-table.sql))

```sql
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    email VARCHAR(255) NOT NULL UNIQUE,
    password_hash VARCHAR(255) NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- Link transactions to users
ALTER TABLE transactions
ADD COLUMN user_id INTEGER,
ADD CONSTRAINT fk_user
    FOREIGN KEY(user_id) 
    REFERENCES users(id)
    ON DELETE CASCADE;
```

**Key Security Feature:** `ON DELETE CASCADE` ensures when a user is deleted, all their transactions are automatically removed.

---

### **Advanced Database Features**

#### **SQL Functions for Complex Analytics**

**Example: Financial Overview** ([`seeds/cashflow/get_financial_overview.sql`](Money Tracking/Original Project/database/seeds/cashflow/get_financial_overview.sql))

```sql
CREATE OR REPLACE FUNCTION get_financial_metrics(p_user_id INT)
RETURNS TABLE(
    report_year TEXT,
    total_income_value DECIMAL,
    expense_category VARCHAR,
    total_expense_value DECIMAL,
    savings_rate_value DECIMAL
) AS $$
BEGIN
    RETURN QUERY
    WITH category_totals AS (
        SELECT 
            ec.category_name,
            TO_CHAR(t.date, 'YYYY') AS year,
            SUM(t.amount) AS total_amount,
            CASE WHEN ec.category_name = 'Income' THEN 'Income' ELSE 'Expense' END AS type
        FROM transactions t
        JOIN expense_categories ec ON t.category_id = ec.id
        WHERE t.user_id = p_user_id  -- ← User-specific filtering
        GROUP BY ec.category_name, year
    ),
    income_total AS (
        SELECT year, SUM(total_amount) AS total_income
        FROM category_totals
        WHERE type = 'Income'
        GROUP BY year
    ),
    expense_total AS (
        SELECT year, category_name, SUM(total_amount) AS total_expense
        FROM category_totals
        WHERE type = 'Expense'
        GROUP BY year, category_name
    ),
    net_income AS (
        SELECT i.year, (i.total_income - COALESCE(m.total_yearly_expenses, 0)) AS total_net_income
        FROM income_total i
        JOIN yearly_expenses m ON i.year = m.year
    )
    SELECT 
        i.year AS report_year,
        i.total_income AS total_income_value,
        e.category_name AS expense_category,
        (e.total_expense / NULLIF(i.total_income, 0)) * 100 AS total_expense_value,
        (n.total_net_income / NULLIF(i.total_income, 0)) * 100 AS savings_rate_value
    FROM income_total i
    JOIN expense_total e ON i.year = e.year
    JOIN net_income n ON i.year = n.year
    ORDER BY i.year, e.category_name;
END;
$$ LANGUAGE plpgsql;
```

**Backend Usage:**
```typescript
export const getFinancialOverview = (userId: string) => {
    return query('SELECT * FROM get_financial_metrics($1)', [userId]);
};
```

---

### **Database Connection** ([`src/db_conn/db.ts`](Money Tracking/Original Project/backend/src/db_conn/db.ts))

```typescript
import { Pool } from 'pg';

const pool = new Pool({
  user: process.env.POSTGRES_USER,
  host: process.env.POSTGRES_HOST,
  database: 'tracker',
  password: process.env.POSTGRES_PASSWORD,
  port: 5432,
});

export const query = (text: string, params?: any[]) => {
    return pool.query(text, params || []);
};
```

**Connection pooling** handles multiple concurrent requests efficiently.

---

### **Migration System** ([`database/src/runMigrations.ts`](Money Tracking/Original Project/database/src/runMigrations.ts))

```typescript
(async () => {
  const direction = process.argv[2] === 'down' ? 'down' : 'up';
  await migrationRunner(direction);
  
  // After migrations, apply seed files
  const seedFiles = findSqlFiles('../seeds');
  for (const file of seedFiles) {
    const sql = fs.readFileSync(file).toString();
    await client.query(sql);
  }
})();
```

**Deployment order:**
1. Create tables (`migrations/*.sql`)
2. Seed reference data (`seeds/*.sql`)
3. Create SQL functions for analytics

---

## **4. Complete Request Flow Example**

### **Scenario: User Adds a New Expense**

#### **Step 1: Frontend** ([`ExpenseFormModal.tsx`](Money Tracking/Original Project/frontend/src/components/ExpenseFormModal.tsx))
```typescript
const handleSubmit = async (event) => {
    const transactionData = {
      date: new Date().toISOString().slice(0, 10),
      amount: parseFloat(amount),
      typeId: selectedTypeId,
      categoryId: selectedCategoryId
    };
    
    const response = await apiFetch('http://localhost:8000/feed/transaction', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${authContext.token}` // ← JWT attached
        },
        body: JSON.stringify(transactionData),
    }, authContext);
};
```

#### **Step 2: Backend Middleware** ([`is-auth.ts`](Money Tracking/Original Project/backend/src/middleware/is-auth.ts))
```typescript
// Extracts JWT, verifies it, attaches userId to request
req.userId = decodedToken.userId;
next();
```

#### **Step 3: Controller** ([`feed.ts`](Money Tracking/Original Project/backend/src/controllers/feed.ts))
```typescript
export const createTransaction = async (req: AuthenticatedRequest, res) => {
    const { date, amount, typeId, categoryId } = transactionSchema.parse(req.body);
    const userId = req.userId; // From JWT
    
    const result = await feedService.createTransaction(
        date, amount, typeId, categoryId, userId
    );
    return res.status(201).json({ transaction: result.rows[0] });
};
```

#### **Step 4: Service Layer** ([`feed.service.ts`](Money Tracking/Original Project/backend/src/services/feed.service.ts))
```typescript
export const createTransaction = (date, amount, typeId, categoryId, userId) => {
    return query(
        'INSERT INTO transactions (date, amount, type_id, category_id, user_id) VALUES ($1, $2, $3, $4, $5) RETURNING *',
        [date, amount, typeId, categoryId, userId]
    );
};
```

#### **Step 5: Database**
```sql
INSERT INTO transactions (date, amount, type_id, category_id, user_id) 
VALUES ('2024-01-15', 150.00, 4, 2, 1) 
RETURNING *;
```

#### **Step 6: Response Chain**
```
Database → Service → Controller → Frontend
  (Row)  →  (JSON)  →  (Status 201) → (Update UI)
```

---

## **5. Security Highlights**

### **Backend Security**
1. **Password Hashing:** bcrypt with 12 salt rounds
2. **JWT Tokens:** 1-hour expiration
3. **Parameterized Queries:** Prevents SQL injection
4. **Input Validation:** Zod schemas for all endpoints
5. **CORS Configuration:** Controlled origin access

### **Frontend Security**
1. **Token Storage:** localStorage (auto-loaded on refresh)
2. **Protected Routes:** `AuthContext` guards dashboard access
3. **Auto-Logout:** Expired/invalid tokens trigger logout
4. **No Password Storage:** Only token persists

### **Database Security**
1. **User Isolation:** All queries filter by `user_id`
2. **Foreign Key Constraints:** Data integrity
3. **Cascade Deletes:** Clean user removal

---

## **6. Deployment Architecture**

### **Docker Compose Setup**

```yaml
services:
  frontend:
    build: ./frontend
    ports:
      - "3001:80"
    depends_on:
      - backend

  backend:
    build: ./backend
    ports:
      - "8000:8000"
    environment:
      - JWT_SECRET=${JWT_SECRET}
      - POSTGRES_USER=tracker_user
    depends_on:
      - database

  database:
    image: postgres:14
    ports:
      - "5432:5432"
    environment:
      - POSTGRES_DB=tracker
      - POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
    volumes:
      - pgdata:/var/lib/postgresql/data

  migrations:
    build: ./database
    command: npm run migrate:up
    depends_on:
      - database
```

**Startup Sequence:**
1. Database container starts
2. Migrations run (create tables, seed data)
3. Backend starts (connects to database)
4. Frontend starts (proxies API calls to backend)

---

## **7. Key Architectural Decisions**

### **Why This Structure?**

| Decision | Reasoning |
|----------|-----------|
| **JWT over Sessions** | Stateless auth, scalable across containers |
| **TypeScript Everywhere** | Type safety reduces runtime errors |
| **Service Layer Pattern** | Business logic separated from HTTP handling |
| **SQL Functions** | Complex analytics performed in database (faster) |
| **Docker Compose** | One-command deployment, environment parity |
| **React Context for Auth** | Global auth state without prop drilling |
| **Recharts for Viz** | Declarative, responsive charts |

### **Data Flow Philosophy**
```
User Action → Frontend (UI Update) → Backend (Validation) → 
Database (Persistence) → Backend (Transform) → Frontend (Display)
```

Every layer has a **single responsibility**, making the system maintainable and testable.

---

## **Summary**

This architecture demonstrates:
- ✅ **Separation of Concerns:** Each layer has clear boundaries
- ✅ **Security First:** JWT auth, password hashing, user isolation
- ✅ **Scalability:** Stateless backend, connection pooling
- ✅ **Developer Experience:** TypeScript, Docker, hot-reload
- ✅ **Production Ready:** Error handling, logging, migrations

The frontend communicates with the backend exclusively through REST APIs, the backend validates and processes requests while enforcing authentication, and the database stores user-specific data with built-in analytics functions. All components are containerized for consistent deployment across environments.